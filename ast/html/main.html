<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AST: Abstract Syntax Tree Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>AST: Abstract Syntax Tree Library</h1><h2><a class="anchor" id="section_toc">
Abstract Syntax Tree Library for TinyJava</a></h2>
<h3><a class="anchor" id="OVERVIEW">
Overview</a></h3>
<p>The AST Libary can be used to create an then traverse abstract syntax trees representing TinyJava programs. The construction of an abstract syntax tree is performed during parsing, by placing suitable AST Library constructor (and other method) calls within the semantic actions of a Bison or YACC specification file for TinyJava.</p>
<p>The root of the syntax tree for a TinyJava program is a node representing the description of the class declaration included in the program.</p>
<h3><a class="anchor" id="NODETYPES">
Abstract Syntax Tree Node Types</a></h3>
<p>The <a class="el" href="classAstNode.html" title="This is the root of the Abstract Syntax Tree class hierarchy.">AstNode</a> class is the root of the syntax tree classes hierarchy. The class has three direct subclasses: <a class="el" href="classDeclaration.html" title="This is the parent of all declaration Abstract Syntax Tree nodes.">Declaration</a>, <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a>, and <a class="el" href="classStatement.html" title="This class is the parent of all statement Abstract Syntax Tree nodes.">Statement</a>, which subdivide the remaining classes into three sections: TinyJava declarations, expressions, and statements, respectively. The four classes mentioned above (<a class="el" href="classAstNode.html" title="This is the root of the Abstract Syntax Tree class hierarchy.">AstNode</a>, <a class="el" href="classDeclaration.html" title="This is the parent of all declaration Abstract Syntax Tree nodes.">Declaration</a>, <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a>, and <a class="el" href="classStatement.html" title="This class is the parent of all statement Abstract Syntax Tree nodes.">Statement</a>) are abstract and therefore are not intended to have any instances.</p>
<p>The AST Library has a number of concrete classes intended to represent all syntactic constructs of TinyJava.</p>
<p>Subclasses of the <a class="el" href="classDeclaration.html" title="This is the parent of all declaration Abstract Syntax Tree nodes.">Declaration</a> class include:</p>
<ul>
<li><a class="el" href="classClassDeclaration.html" title="This class represents a TinyJava class declaration.">ClassDeclaration</a>, which represents a class declaration, including its name and member Declarations, each of which must be either a <a class="el" href="classFieldDeclaration.html" title="This class represents a field declaration in a TinyJava class.">FieldDeclaration</a> or a <a class="el" href="classMethodDeclaration.html" title="This class represents a method declaration in a TinyJava class.">MethodDeclaration</a>.</li>
<li><a class="el" href="classFieldDeclaration.html" title="This class represents a field declaration in a TinyJava class.">FieldDeclaration</a>, which represents a declaration of a class field, including its name, an initialization literal, and type, as described in <a class="el" href="main.html#TYPES">Types and operators in Abstract Syntax Trees</a></li>
<li><a class="el" href="classMethodDeclaration.html" title="This class represents a method declaration in a TinyJava class.">MethodDeclaration</a>, which represents a method declaration, including its name, return type, parameters (<a class="el" href="classParameterDeclaration.html" title="This class represents a declaration of a formal parameter of a TinyJava class method...">ParameterDeclaration</a>), local variables (<a class="el" href="classVariableDeclaration.html" title="This class represents a declaration of a local variable in a TinyJava class method...">VariableDeclaration</a>) and a <a class="el" href="classBlockStatement.html" title="This class represents a TinyJave block statement; local variables are not represented...">BlockStatement</a>, representing the method body</li>
<li><a class="el" href="classParameterDeclaration.html" title="This class represents a declaration of a formal parameter of a TinyJava class method...">ParameterDeclaration</a>, which represents a declaration of a formal parameter of a method, including its name and type, and</li>
<li><a class="el" href="classVariableDeclaration.html" title="This class represents a declaration of a local variable in a TinyJava class method...">VariableDeclaration</a>, which represents a declaration of a local variable in a method, including its name, type and an initialization.</li>
</ul>
<p>Subclasses of the <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a> class include:</p>
<ul>
<li><a class="el" href="classLiteralExpression.html" title="This class represents a TinyJava literal (smallest expression).">LiteralExpression</a>, which represents a literal, represented by the literal string and the literal type</li>
<li><a class="el" href="classReferenceExpression.html" title="This class represents an identifier reference in a TinyJava expression; may be an...">ReferenceExpression</a>, which represents an identifier reference, including the identifier and a symbol table ENTRY pointer</li>
<li><a class="el" href="classUnaryExpression.html" title="This class represents a TinyJava (prefix or postfix) unary expression involving a...">UnaryExpression</a>, which represents a unary expression, including an operand <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a> and a unary (prefix or postfix) operator, as defined in <a class="el" href="main.html#TYPES">Types and operators in Abstract Syntax Trees</a></li>
<li><a class="el" href="classBinaryExpression.html" title="This class represents a TinyJava binary expression involving a binary operator and...">BinaryExpression</a>, which represents a binary expression, including two operands (of type <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a>) and a binary operator</li>
<li><a class="el" href="classCastExpression.html" title="This class represents a TinyJava type cast expression.">CastExpression</a>, which represents a type cast expression, including a type of the cast and an operand <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a></li>
<li><a class="el" href="classMethodCallExpression.html" title="This class represents a TinyJava method call expression.">MethodCallExpression</a>, which represents a method call expression, including the method name and the arguments, each of type <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a></li>
<li><a class="el" href="classNewExpression.html" title="This class represents a TinyJava NEW expression (used for array creation).">NewExpression</a>, which represents a new expression (used for array creation), including the base type and an <a class="el" href="classExpression.html" title="This is the parent of all expression Abstract Syntax Tree nodes.">Expression</a> specifying the array size.</li>
</ul>
<p>Finally, subclasses of the <a class="el" href="classStatement.html" title="This class is the parent of all statement Abstract Syntax Tree nodes.">Statement</a> class include:</p>
<ul>
<li><a class="el" href="classAssignStatement.html" title="This class represents a TinyJava assignment statement.">AssignStatement</a>, which represents an assignment statement</li>
<li><a class="el" href="classBlockStatement.html" title="This class represents a TinyJave block statement; local variables are not represented...">BlockStatement</a>, which represents a block statement</li>
<li><a class="el" href="classEmptyStatement.html" title="This class represents a TinyJava empty statement.">EmptyStatement</a>, which represents an empty statement</li>
<li><a class="el" href="classForStatement.html" title="This class represents a TinyJava FOR statement.">ForStatement</a>, which represents a FOR statement</li>
<li><a class="el" href="classIfStatement.html" title="This class represents a TinyJava IF statement.">IfStatement</a>, which represents IF statement</li>
<li><a class="el" href="classMethodCallStatement.html" title="This class represents a TinyJava method call statement.">MethodCallStatement</a>, which represents method call statement</li>
<li><a class="el" href="classReturnStatement.html" title="This class represents a TinyJava return statement, with or without an expression...">ReturnStatement</a>, which represents a return statement node in an abstract syntax tree</li>
<li><a class="el" href="classWhileStatement.html" title="This class represents a TinyJava WHILE statement.">WhileStatement</a>, which represents a while statement</li>
</ul>
<p>Some of the above (concrete) classes, for example <a class="el" href="classReferenceExpression.html" title="This class represents an identifier reference in a TinyJava expression; may be an...">ReferenceExpression</a>, can represent a pointer to the symbol table entry corresponding to the represented element. The type of the symbol table entry is defined as a pre-processor macro called ENTRY and it should be a legal C++ class. The AST library is not making any assumptions as to the representation of the symbol table entry or its interface, except that it is a class. The default value of the macro is Entry. If your symbol table entry is a different class, you should define the ENTRY macro accordingly and place the definition before you include the Ast.h file.</p>
<h3><a class="anchor" id="TYPES">
Types and operators in Abstract Syntax Trees</a></h3>
<p>TinyJava types and operators are represented as public constants defined in the <a class="el" href="classAstNode.html" title="This is the root of the Abstract Syntax Tree class hierarchy.">AstNode</a> class. These constants can be used in your symbol table entries for field types, method return types and formal parameter types, as well as the types of local variables.</p>
<p>The <a class="el" href="classAstNode.html" title="This is the root of the Abstract Syntax Tree class hierarchy.">AstNode</a> class defines a number int constants that represent TinyJava types. These include:</p>
<ul>
<li><a class="el" href="classAstNode.html#ac664e0864b9c856e947d5fde632eb5e7">AstNode::TVOID</a> (void type representation)</li>
<li><a class="el" href="classAstNode.html#a8568313f5d280773a446280c94d382f8">AstNode::TINT</a> (int type representation)</li>
<li><a class="el" href="classAstNode.html#abf470f775bd7a7bfc2c0610716054339">AstNode::TFLOAT</a> (float type representation)</li>
<li><a class="el" href="classAstNode.html#a71904f4c33eff3bb3a37fadda88f12c9">AstNode::TBOOL</a> (boolean type representation)</li>
<li><a class="el" href="classAstNode.html#a2245a2aec841592ecddf8f9497306a4b">AstNode::TSTRING</a> (String type representation)</li>
<li><a class="el" href="classAstNode.html#a7233043e1a9d95c3120a62ac66c89608">AstNode::TINTA</a> (int[] type representation)</li>
<li><a class="el" href="classAstNode.html#a9d01a6ac8a4a7a5b2d4a3ec8a7e93fa7">AstNode::TFLOATA</a> (float[] type representation)</li>
<li><a class="el" href="classAstNode.html#ae3a9310b89b8c86afe245cf88ab1369a">AstNode::TSTRINGA</a> (String[] type representation)</li>
<li><a class="el" href="classAstNode.html#ad84a595b7727d93d325664d5bf89c766">AstNode::TREF</a> (basic reference type representation, to be used for null expression type)</li>
</ul>
<p>Also, the <a class="el" href="classAstNode.html" title="This is the root of the Abstract Syntax Tree class hierarchy.">AstNode</a> class defines a number of public constants that represent TinyJava operators. These include:</p>
<ul>
<li><a class="el" href="classAstNode.html#af908b13b6954116a438f86ce595d5bfe">AstNode::ADDOP</a>, which represents the "+" operator (prefix or infix)</li>
<li><a class="el" href="classAstNode.html#a8d62c361a16d84b762172fac68650561">AstNode::SUBOP</a>, which represents the "-" operator (prefix or infix)</li>
<li><a class="el" href="classAstNode.html#af1564bffc1a770122ea56654f4439531">AstNode::MULOP</a>, which represents the "*" operator</li>
<li><a class="el" href="classAstNode.html#a3972892cd58f1c70c84366804bdfd371">AstNode::DIVOP</a>, which represents the "*" operator</li>
<li><a class="el" href="classAstNode.html#a9cb6a842a496aed85756aa779789ce77">AstNode::EQOP</a>, which represents the "==" operator</li>
<li><a class="el" href="classAstNode.html#a3347eacf3e38675c075a7ce1c4cb6e29">AstNode::NEOP</a>, which represents the "!=" operator</li>
<li><a class="el" href="classAstNode.html#a1ddf9dbcce4b80d311e7080b8262b65b">AstNode::LTOP</a>, which represents the "&lt;" operator</li>
<li><a class="el" href="classAstNode.html#a3103a273c9da38b092334c757ee19ace">AstNode::GTOP</a>, which represents the "&gt;" operator</li>
<li><a class="el" href="classAstNode.html#ac62da8b0313271a74293826f586dd6ea">AstNode::LEOP</a>, which represents the "&lt;=" operator</li>
<li><a class="el" href="classAstNode.html#aeb92e9f6e1407ff0c945f220b3da9820">AstNode::GEOP</a>, which represents the "&gt;=*" operator</li>
<li><a class="el" href="classAstNode.html#abf9092d925819312d2547c414b493c4f">AstNode::INCOP</a>, which represents the "++" operator (postfix), and</li>
<li><a class="el" href="classAstNode.html#a0a48e47b23689fb51c059cb48a007adc">AstNode::DECOP</a>, which represents the "--" operator (postfix).</li>
</ul>
<h3><a class="anchor" id="EXCEPTIONS">
Abstract Syntax Trees exceptions</a></h3>
<p>The <a class="el" href="classAstException.html" title="This class represents an exception that may occur within the Abstract Syntax Tree...">AstException</a> class is used to represent some problem within the library. If one of the available AST Library constructors or other methods throws an <a class="el" href="classAstException.html" title="This class represents an exception that may occur within the Abstract Syntax Tree...">AstException</a>, the message indicates the type of the problem encountered.</p>
<h3><a class="anchor" id="VISITORS">
Abstract Syntax Trees visitors</a></h3>
<p>The AST Libary provides the <a class="el" href="classAstVisitor.html" title="This is the parent of all Abstract Syntax Tree visitors; it is an abstract class...">AstVisitor</a> class, which is the base abstract class for implementing a variety of visitors to abstract syntax trees representing TinyJava programs. The vistors follow the well-known <a href="http://sourcemaking.com/design_patterns/visitor">Visitor Design Pattern</a>. The <a class="el" href="classAstVisitor.html" title="This is the parent of all Abstract Syntax Tree visitors; it is an abstract class...">AstVisitor</a> class provides a number of pure virtual methods, one for each of the concrete classes included in the <a class="el" href="classAstNode.html" title="This is the root of the Abstract Syntax Tree class hierarchy.">AstNode</a> hierarchy.</p>
<p>Once an abstract syntax tree for a TinyJava class has been created, specialized visitors can print out the entire synatx tree (for debugging purposes), construct the symbol table for the program, perform its semantic analysis, and finally generate the intermediate code.</p>
<p>The AST Library includes a simple PrintVisitor class. This class illustrates how to perform a traversal of the entire syntax tree. Additional visitors can be implemented in a similar fashion.</p>
<h3><a class="anchor" id="USING">
Using the AST Library</a></h3>
<p>You may copy the source code of the AST Library into your own space and use make to compile the library. Alternatively, you may use a copy of the library on nike, which is in my directory /home/profs/kochut/csx570/ast. You should use appropriate options on your g++ compilation commands (for example, -I, -L and -l) to use the library. After compilation, the AST Library directory should contain the library file called libAst.so, which is a shared object. Additional explanations will be provided in class.</p>
<p>In order to use the library, you should include the header file Ast.h, for example in your Bison specification file for TinyJava. If you would like to store references to your symbol table entries in a syntax tree, and if your symbol table entry class is not called Entry (upper case E), you should define the ENTRY macro ahead of the include "Ast.h" directive. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 19 Mar 2012 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
